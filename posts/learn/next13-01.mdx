---
title: next13学习记录01
date: '2023-08-27 16:30:25'
tags:
  - 前端
  - react
  - next.js(App)
toc: true
heroImage: ''
heroImageAspectRatio: ''
draft: false
updatedOn: '2023-08-30 01:47'
---

![Image 1693127662389](/images/27e15758f70a27d9ca91f2c91d09d086c4ca75f53104cc99069232ee48b043be.jpg)

## 前情提要

最近终于有点时间, 想起来自己已经写 angular 一年多了, 再不写写别的框架都不会写前端

同时前段时间 blog 挂掉了, 于是就想换个语言写写, 尽量和现在的技术栈不一样

## 技术选型

前几天在 https://www.v2ex.com/t/967560 看到 react 有好多新东西, 之前不喜欢用 react 就是因为 class component 和 jsx 以及 css in js 这些东西都长的很丑, 实在是跟优雅没什么关系

但是现在有 tailwindcss 和 函数式组件了, 感觉和之前学的 vue3.2 也差不多了(, 另外看到 radix/shadcn 组件库是真的好用, 于是就决定用 react 全家桶了

写 angular 的时候, ivy 的 aot 虽然很好用, 但干什么都要注册一大堆东西, 最近的一个项目我已经简化了非常多了, 但还是写着很麻烦, 然后看到 next.js 的文件结构路由, 感觉 angular 这块是真的啰嗦 😂

还有一点就是, angular 16 也开始弄 reactive 属性了, 前端三大框架都开始搞 fp + immutable 了, 那 angular 的优势还有什么呢? 🤔️

## 踩坑记录 01

### App router

其实学 next.js 的时机有点巧, 正好 next 13 大改了一堆东西, 之前的文档都过时了, 学新的这套历史包袱少多了. 但问题是教程也很少 😂, 正好也啃啃官方文档, 就当学英语了

app router 一个核心的改变就是把之前的 getStaticPaths/getStaticProps 等几个 ssr/ssg api 改了(见 https://nextjs.org/docs/app/api-reference/file-conventions, 顺便提一嘴, 这个文档也是我第一次看到文档有写项目结构和文件结构的, 每个文件里要写什么能写什么, 例子都给的很全, 写的是真好), getStaticPaths 换成用 generateStaticParams 了, 原来的一些参数也都改成 Route Segment Config 了.

然后 getStaticProps 就直接去掉了, 现在自己随便写一个方法调用就好了, 写起来其实比之前还舒服一点, api 又少了一个.

### 部署

一开始我还以为 build 完和别的框架差不多, 会直接有一个 index.html 之类的东西, 结果 build 里面一堆乱七八糟的东西, 查了查才看到有个 output 选项, 用这个就可以 build 出来一堆 html 文件, 然后随便用啥就可以部署了.

当然对于我这种大部分页面都是 ssg 的项目来说, 随便找个什么地方部署都行, 那不如直接用 vercel 的工具部署, 每次推送一下更新就自动编译了, CI 都不用自己搞了.

### Eslint 和 自动化

一直以来都是顺其自然的用 eslint 和 perttier 这些东西, 也都没怎么研究过 src 外面的配置文件一大堆都是干嘛的.

这次花了很多时间自己配了一套 eslint 和 perttier 的配置, 其实配起来也是满简单的, 就是 config 和 plugin 里面引入一下配置, 然后根据手动调整一下规则就好了, 弄完之后 lint 一下, 感觉特别爽(

另外一块就是弄了 prettier 的配置, 前段时间一直有强迫症, 都用 perttier 重排序 import, 但是默认配置其实就只是字母排序一下, 排完其实变得更乱了, 各种不同的依赖都互相引入, 看着也不是很爽. 这次看到 shadcn 给的模版用了一个 prettier-plugin-sort-imports 库, 研究了一下这个怎么用, 终于可以根据自己想要的格式来排序依赖了, 感觉特别特别爽(

最后还弄了点自动化, 以前一直好奇 npm script 里面的 prepare 是干嘛的, 现在才搞懂这个可以用来配置自动化, 配合 lintstaged, 可以自动 eslint 检查以及文章自动更新时间等等功能, 写文章越来越方便了(

### window is not defined

<LinkCard
  url="https://nextjs.org/docs/app/building-your-application/rendering/client-components#how-are-client-components-rendered"
  symbol="@"
  title="How are Client Components Rendered?"
  description="In Next.js, Client Components are rendered differently depending on whether the request is part of a full page load (an initial visit to your application or a page reload triggered by a browser refresh) or a subsequent navigation."
/>

在 next 13 之后, app router 下的 tsx 和以前的是完全不一样的, 首先它会在服务端预渲染服务端组件的 html, 然后再客户端显示并使用 hydration, 这里有一个误区, 当使用 "use client" 时, 很容易以为在整个函数式组件执行过程中都有 window, dom 等东西, 但实际上需要等到 useLayoutEffect 时, 你才能获取到这个值, 否则哪怕你对 window 属性用了可选链, 他仍然会报错(这里还是有点疑惑的, 之后会继续研究)

在 src 和 crc 组件混用的情况下, 通常的设计是: 
  - 将数据获取的部分写成服务端渲染, 这部分代码甚至可以使用诸如 fs path 这样的 node.js 库
    - 然后将服务端组件的获取到的数据传给客户端组件
  - 将固定的, 没有复杂 js 操作的部分写成服务端渲染, 例如 button, link 这样的轻组件
  - 将复杂的, 对页面改动极大的组件设置写成客户端渲染
  - 将需要在线数据的, 或需要 useEffect 的地方写成客户端渲染
  - 将本地储存, 编译时就确定的数据写成 SSG 模式, SSG 不影响使用 src 或 crc 组件

最后补充一段 react 官方两年前的设计

<YouTube videoId="TQQPAU21ZUw" />

关于 next 13 的 src 等新东西, 还有很多坑要踩, 如何在服务端和客户端直接方便的传输数据, 控制全局变量的生效等, 就留作以后继续研究了
